/* sample3 - a sample module -- module with /proc read/write functions */

#include <linux/version.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/proc_fs.h>

MODULE_AUTHOR("Bob Russell <rdr@unh.edu>");
MODULE_DESCRIPTION("CS721/821 sample3");
MODULE_LICENSE("GPL");

/*	static storage used to save this module's /proc registration address */
static struct proc_dir_entry *entry = NULL;

/*	function by which user "reads" data generated by the proc "file"
 *	return value is number of bytes of new data put into buffer
 *		(=0 for end of file, <0 for error)
 *	page is address of buffer to put first byte of new data
 *	start returns NULL or actual address within buffer of first new byte
 *	offset is offset within the file (the lseek position)
 *	count is the total number of bytes in the buffer
 *	eof returns 1 if this amount of data would end
 */
static int
my_read_proc( char *page, char **start, off_t offset, int count, int *eof,
		void *data )
{
	int len;
	unsigned int	*counter;

	if ((counter = data) != NULL) {
		*counter += 1;
		len = sprintf(page, "sample3: my_read_proc, "
				"private data at %p, read refs %u, "
				"write refs %u\n",
				counter, counter[0], counter[1]);
		if (*(char *)(counter+2) != '\0') {
			/* a previous write wrote into our private data */
			len += sprintf(page+len, "sample3: prev write into "
				"buffer: %s\n",
				(char *)(counter+2));
		}
	} else {
		len = sprintf(page, "sample3: my_read_proc, "
				"no reference data allocated\n");
	}
	if (len >= offset)
		*eof = 1;
	printk("sample3: my_read_proc: len %d, count %d, offset %d, eof %d\n",
		len, count, (int)offset, *eof);
	printk("sample3: my_read_proc: data %s", page);
	return len;
}


/*	function by which user "writes" to the proc "file"
 *	buffer contains the data written to us by the user
 *	count is number of bytes of data in buffer
 */
static int
my_write_proc( struct file *fptr, const char *buffer, unsigned long count,
		void *data )
{
	unsigned int	*counter;
	unsigned long	my_count;

	if ((counter = data) != NULL) {
		*(counter+1) += 1;
		printk("sample3: my_write_proc, "
			"private data at %p, read refs %u, "
			"write refs %u\n",
			counter, counter[0], counter[1]);
		if (*(char *)(counter+2) != '\0') {
			/* a previous write wrote into our private data */
			printk("sample3: prev write into buffer: %s\n",
				(char *)(counter+2));
		}
	} else {
		printk("sample3: my_write_proc, "
				"no reference data allocated\n");
	}
	printk("sample3: my_write_proc: count %lu\n", count);
	if (count > 0) {
		if (count >= PAGE_SIZE - 2 * sizeof(unsigned long)) {
			my_count = PAGE_SIZE - 2 * sizeof(unsigned long) - 1;
		} else {
			my_count = count;
		}
		/* copy buffer into our page area and drop any newline at end */
		if (counter != NULL) {
			memcpy((char *)(counter+2), buffer, my_count);
			if (((char *)(counter+2))[count-1] == '\n')
				((char *)(counter+2))[count-1] = '\0';
			else
				((char *)(counter+2))[count] = '\0';
			printk("sample3: my_write_proc: buffer \"%s\"\n",
				(char *)(counter+2));
		}
	}
	printk("sample3: my_write_proc: returning %lu\n", count);
	return count;
}

/*	function to initialize this module when it is loaded
 *	Returns 0 if everything worked ok
 *		-EXXXX error code if something went wrong
 */
static int __init
sample_init_module_function(void)
{
	unsigned int	*counter;

	printk("sample3: up and running ok\n");
	/* create a new read/write file in the top-level "/proc" directory */
	entry = create_proc_entry("sample3", S_IRUGO|S_IWUGO, NULL);
	if (entry) {
		printk("sample3: entry %p added to /proc\n", entry);
		/* give this new file both read and write functions plus data */
		entry->read_proc = &my_read_proc;
		entry->write_proc = &my_write_proc;
		/* try to allocate private data area, could return NULL */
		if ((entry->data = (void *)__get_free_page(GFP_KERNEL))!=NULL) {
			memset(entry->data, 0, PAGE_SIZE);
			printk("sample3: private data of %lu bytes at %p\n",
				PAGE_SIZE, entry->data);
			counter = entry->data;
			printk("sample3: initial counters, "
				"read refs %u, write refs %u\n",
				*counter, *(counter + 1));
		} else {
			printk("no private data allocated\n");
		}
		return 0;	/* everything ok */
	} else {
		printk("sample3: add to /proc FAILED!\n");
		return -ENOMEM;
	}
}

/*	function to clean up this module when it is unloaded */
static void __exit
sample_cleanup_module_function(void)
{
	unsigned int	*counter;

	printk("sample3: closing down now\n");
	if (entry) {
		remove_proc_entry("sample3", NULL);
		/* free any data page we may have allocated on start up */
		if ((counter = entry->data) != NULL) {
			printk("sample3: cleanup, "
				"private data at %p, read refs %u, "
				"write refs %u\n",
				counter, counter[0], counter[1]);
			free_page((unsigned long)entry->data);
			entry->data = NULL;
		}
		printk("sample3: entry %p removed from /proc\n", entry);
		entry = NULL;
	}
	printk("sample3: closed down ok\n");
}

module_init(sample_init_module_function);
module_exit(sample_cleanup_module_function);

/* vi: set autoindent tabstop=8 shiftwidth=8 : */
